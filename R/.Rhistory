###################################
#     Two-dimentional kernel     ##
#  resampling of dispersal data  ##
#                                ##
#             INDEX              ##
#      -1. load library(ies)     ##
#       0. assign a dataset      ##
#       1. randomize theta,      ##
#  create 2-dimentional kernel,  ##
#          and resample          ##
#    2. find distribution mean   ##
#       and standard error       ##
#         3. plot data           ##
#                                ##
#       ~written by isadore nabi~##
###################################
#
# -1. load library(ies)#
     library(MASS) #for kde2d and plotting functions#
#
# 0. assign a dataset#
	# 0.0 clear objects and set seed#
	rm(list = ls())#
	set.seed(6174) #Kaprekar's constant#
#
	# 0.1 100 data points with x and y coordinates#
	data.points <- 200#
	bi.var.norm <- cbind(rnorm(n = data.points, mean = 0 , sd = 15 ) , rnorm(n = data.points, mean = 0 , sd = 15 ))#
	disp.data <- (bi.var.norm[,1]^2 + bi.var.norm[,2]^2)^0.5#
#
# 1. randomize theta, create 2-dimentional kernel, and resample#
	# 1.0 loop#
	samples <- 250 #remember that it is going to be 4 per sample because we're extracing the Cartesian coordinates#
	breaks <- max(ceiling(disp.data)) # finds largest distance and creates that many breaks to correspond to one per unit distance#
#
	w.mat <- matrix(data = NA , nrow = samples*4 , ncol = breaks , byrow = T) # for density distribution data (as omega) pre-allocation#
	f.mat <- matrix(data = NA , nrow = samples*4 , ncol = breaks , byrow = T) # for distance distribution data (as f) pre-allocation#
#
	distances <- 1:ncol(w.mat)#
#
	for (i in 0:(samples-1)){#
		# 1.1 draw theta for number of dispersal sampels#
		theta <- round(runif(length(disp.data) , max = 360) , 1)#
	#
		# 1.2 convert polar cordinates to bearing#
		polar2cart <- function(x , y , dist , bearing , as.deg = FALSE){#
			  if(as.deg){#
			    bearing = bearing * pi / 180#
			  }#
		  new.x <- x + dist*sin(bearing)#
		  new.y <- y + dist*cos(bearing)#
		  return(list("x" = new.x,"y" = new.y))#
		}#
		points.2D <- polar2cart(0 , 0 , disp.data, theta)#
	#
		# 1.3 create 2D pdf#
		kernel.2D <- kde2d(points.2D$x , points.2D$y , n = breaks*2)#
#
		# 1.4 z-values for a sample from pole across a Cartetian ray#
		max.x <- sort(kernel.2D$z[(breaks+1):(breaks*2) , breaks] , decreasing = T)#
		min.x <- sort(kernel.2D$z[1:breaks , breaks] , decreasing = T)#
		max.y <- sort(kernel.2D$z[breaks , 1:breaks] , decreasing = T)#
		min.y <- sort(kernel.2D$z[breaks , (breaks+1):(breaks*2)] , decreasing = T)#
#
		w.mat[(i*4+1),] <- max.x/sum(max.x)#
		w.mat[(i*4+2),] <- min.x/sum(min.x)#
		w.mat[(i*4+3),] <- max.y/sum(max.y)#
		w.mat[(i*4+4),] <- min.y/sum(min.y)#
#
		f.r.max.x <- max.x*2*pi*distances#
		f.r.min.x <- min.x*2*pi*distances#
		f.r.max.y <- max.y*2*pi*distances#
		f.r.min.y <- min.y*2*pi*distances#
#
		f.mat[(i*4+1),] <- f.r.max.x/sum(f.r.max.x)#
		f.mat[(i*4+2),] <- f.r.min.x/sum(f.r.min.x)#
		f.mat[(i*4+3),] <- f.r.max.y/sum(f.r.max.y)#
		f.mat[(i*4+4),] <- f.r.min.y/sum(f.r.min.y)#
	}#
#
	# 1.4 structural checks#
		#1.4.0 head, tails, and row sums#
		w.mat[1:5 , 1:5] # head should be larger than the tail (next line below)#
		w.mat[1:5 , (ncol(w.mat)-5):ncol(w.mat)] # tail#
		w.mat[(nrow(w.mat)-5):nrow(w.mat) , 1:5] # head should be larger than the tail (next line below)#
		w.mat[(nrow(w.mat)-5):nrow(w.mat) , (ncol(w.mat)-5):ncol(w.mat)] # tail#
		apply(w.mat , 1 , sum) # summing to unity means the sum of rows all should = 1#
	#
		f.mat[1:5 , 1:5] # head should be larger than the tail (next line below)#
		f.mat[1:5 , (ncol(f.mat)-5):ncol(f.mat)] # tail#
		f.mat[(nrow(f.mat)-5):nrow(f.mat) , 1:5] # head should be larger than the tail (next line below)#
		f.mat[(nrow(f.mat)-5):nrow(f.mat) , (ncol(f.mat)-5):ncol(f.mat)] # tail#
		apply(f.mat , 1 , sum) # summing to unity means the sum of rows all should = 1#
#
#
# 2. find distribution mean and standard error#
	# 2.0 density distance pdf#
	wr.mean <- apply(w.mat , 2 , mean)#
	wr.sem <- apply(w.mat , 2 , sd)/(nrow(w.mat)^0.5)#
#
	# 2.1 location distance pdf#
	fr.mean <- apply(f.mat , 2 , mean)#
	fr.sem <- apply(f.mat , 2 , sd)/(nrow(f.mat)^0.5)#
#
# 3. plot data#
	# 3.0 Continuous box plots#
	box.stats.w <- boxplot(w.mat , plot = F)$stats[-3,]#
	box.stats.f <- boxplot(f.mat , plot = F)$stats[-3,]#
#
# png("/Users/christophermoore/Projects/dispersing.github.io/img/dispcurves.png", width = 480, height = 250)#
	par(mfrow = c(2,1) , mar = c(0.5,0.5,0.5,0.5) , oma = c(1,1,1,1))#
	plot(0 , type = "n" , ylim = c(0, max(w.mat)) , xlim = c(0,length(box.stats.w[4,])) , xlab = "" , ylab = "" , xaxt = "n", yaxt = "n")#
	polygon(c(1:length(box.stats.w[4,]),length(box.stats.w[4,]):1),c(box.stats.w[4,],rev(box.stats.w[1,])) , col = rgb(0,0,1,1/3) , border = F)#
	polygon(c(1:length(box.stats.w[4,]),length(box.stats.w[4,]):1),c(box.stats.w[3,],rev(box.stats.w[2,])) , col = rgb(0,0,.75,2/3) , border = F)#
	lines(wr.mean , col = "red" , lwd = 2 , lend = 1)#
	abline(h = 0 , v = 1 , lwd = 0.75 , col = "black")#
	# axis(1 , labels = F)#
	# axis(2 , labels = F)#
#
	plot(0 , type = "n" , ylim = c(0, max(f.mat)) , xlim = c(0, length(box.stats.f[4,])) , xlab = "" , ylab = "" , xaxt = "n", yaxt = "n")#
	polygon(c(1:length(box.stats.f[4,]),length(box.stats.f[4,]):1),c(box.stats.f[4,],rev(box.stats.f[1,])) , col = rgb(0,0,1,1/3) , border = F)#
	polygon(c(1:length(box.stats.f[4,]),length(box.stats.f[4,]):1),c(box.stats.f[3,],rev(box.stats.f[2,])) , col = rgb(0,0,.75,2/3) , border = F)#
	lines(fr.mean , col = "red" , lwd = 2 , lend = 1)#
	abline(h = 0, v = 1 , lwd = 0.75 , col = "black")#
	mtext("Distance from pole" , side = 1 , line = -0.25)#
	mtext("Probability" , side = 2 , line = 0.25 , outer = T)#
#
	# axis(1 , labels = F)#
	# axis(2 , labels = F)#
# dev.off()#

png("/Users/christophermoore/Projects/dispersing.github.io/img/dispcurves.png", width = 250, height = 480)#
	par(mfrow = c(2,1) , mar = c(0.5,0.5,0.5,0.5) , oma = c(1,1,1,1))#
	plot(0 , type = "n" , ylim = c(0, max(w.mat)) , xlim = c(0,length(box.stats.w[4,])) , xlab = "" , ylab = "" , xaxt = "n", yaxt = "n")#
	polygon(c(1:length(box.stats.w[4,]),length(box.stats.w[4,]):1),c(box.stats.w[4,],rev(box.stats.w[1,])) , col = rgb(0,0,1,1/3) , border = F)#
	polygon(c(1:length(box.stats.w[4,]),length(box.stats.w[4,]):1),c(box.stats.w[3,],rev(box.stats.w[2,])) , col = rgb(0,0,.75,2/3) , border = F)#
	lines(wr.mean , col = "red" , lwd = 2 , lend = 1)#
	abline(h = 0 , v = 1 , lwd = 0.75 , col = "black")#
	# axis(1 , labels = F)#
	# axis(2 , labels = F)#
#
	plot(0 , type = "n" , ylim = c(0, max(f.mat)) , xlim = c(0, length(box.stats.f[4,])) , xlab = "" , ylab = "" , xaxt = "n", yaxt = "n")#
	polygon(c(1:length(box.stats.f[4,]),length(box.stats.f[4,]):1),c(box.stats.f[4,],rev(box.stats.f[1,])) , col = rgb(0,0,1,1/3) , border = F)#
	polygon(c(1:length(box.stats.f[4,]),length(box.stats.f[4,]):1),c(box.stats.f[3,],rev(box.stats.f[2,])) , col = rgb(0,0,.75,2/3) , border = F)#
	lines(fr.mean , col = "red" , lwd = 2 , lend = 1)#
	abline(h = 0, v = 1 , lwd = 0.75 , col = "black")#
	mtext("Distance from pole" , side = 1 , line = 0.25)#
	mtext("Probability" , side = 2 , line = -0.25 , outer = T)#
#
	# axis(1 , labels = F)#
	# axis(2 , labels = F)#
dev.off()#

